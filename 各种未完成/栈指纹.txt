FIN 探测器 -- 这里我们送一个FIN包（或任何其他包不带ACK 或SYN
标记）给一个打开的端口并等待回应。正确的RFC793行为是不
响应，但许多有问题的实现例如 MS Windows, BSDI, CISCO, 
HP/UX,MVS,和IRIX 发回一个RESET。许多现有工具利用这个技
术。

设置一个未定义的TCP "标记"（64或128）在SYN
包的TCP头里。Linux机器到2.0.35之前在回应中保持这个标记。
我没有发现其他OS有这个错误。然而，一些操作系统象是复位
连接当它们得到一个SYN+ BOGUS包的时候。这一行为对辨识它
们有用。

TCP ISN 取样 -- 这个主意是找出当响应一个连接请求时由TCP 实现
所选择的初始化序列数式样。这可分为许多组例如传统的64K
（许多老UNIX机器），随机增量（新版本的Solaris, IRIX, FreeBSD,
Digital UNIX, Cray, 和许多其他的），真“随机”（Linux 2.0.*,
OpenVMS,新的AIX,等）。Windows 机器（和一些其他的）用一
个“时间相关”模型，每过一段时间ISN 就被加上一个小的固
定数。不用说，这几乎和老的64K 行为一样容易攻破。当然我
喜欢的技术是"常数"。机器总是使用确切同样的ISN :)。我已
经在3Com的集线器（用0x803）和Apple LaserWriter打印机（
用0xC7001 ）上看到了。

TCP 初始化窗口 -- 这只包括了检查返回包的窗口大小。较老的扫描 
器简单地用一个非零窗口在RST包中来表示“BSD 4.4 族”。新
一些的如queso 和nmap则保持对窗口的精确跟踪因为它对于特定
OS基本是常数。这个测试事实上给出许多信息，因为有些可以被
唯一确定（例如，AIX 是所知唯一用0x3F25的）。在它们“完全
重写”的NT5 TCP 栈中，Microsoft 用的是0x402E。有趣的是，
这和OpenBSD 与FreeBSD 中所用的数字完全一样。

ACK 值 -- 尽管你会认为这个会完全标准，不同实现中一些情况下ACK
域的值是不同的。例如，如果你送了一个FIN|PSH|URG 到一个
关闭的TCP 端口。大多数实现会设置ACK 为你的初始序列数，
而Windows 和一些傻打印机会送给你序列数加1 。若你送一个
SYN|FIN|URG|PSH 到一个打开的端口，Windows 会非常古怪。
一些时候它送回序列号，但也有可能送回序列号加1， 甚至还
可能送回一个随机数。我们觉得奇怪，不知微软写的是些什么
代码。

ICMP 消息引用 -- RFC 规定ICMP错误消息可以引用一部分引起错误
的源消息。对一个端口不可达消息，几乎所有实现只送回IP请
求头外加8 字节。然而，Solaris 送回的稍多，而Linux 更多。
这使得nmap甚至在没有对方没有监听端口的情况下认出Linux 
和Solaris 主机。

对于ICMP端口不可达消息我察看送回包的服务类型(TOS)
值。几乎所有实现在这个ICMP错误里用0 除了Linux 用0xc0。
这不是标准的TOS 值，而是一个未使用优先域(AFAIK) 的一部
分。我不知道为什么如此，但如果他们改成0 我们还能够分辨
旧系统_而且_还能分辨出旧系统和新系统。

